BeginDocument(IF,5,Scott M. Denton and Patrick J. Miller)

BeginSection(NAME)
IF1/IF2/IF90 \- data flow intermediate form languages
EndSection(NAME)

BeginSection(SYNOPSIS)
IF1, IF2, and IF90 are intermediated forms for applicative languages
based upon acyclic graphs.  IF* defines languages that are the targets 
of several compilers and languages.  By exchanging programs 
translated from different sources to IF*, the rather limited resources 
of programs written in applicative languages may be shared.  The 
language defined is not sufficiently general to be used by implementors 
of all applicative languages however; it is strongly biased towards the 
features of SISAL [McGraw 1985] and VAL [Ackermann 1979].

IF1 is a functional representation with nodes, edges, types and graph
boundaries.  Nodes denote operations, such as add or divide; edges 
represent values that are passed from node to node; and types can be
attached to each edge or function.  Graph boundaries surround groups 
of nodes and edges.

IF2 is an extension of IF1 with synchronization and explicit memory 
allocation and manipulation.

IF90 is a higher level addition to IF1 with added expressability.  
IF90 graphs may be translated to IF1 with only the loss of succinctness.
EndSection(SYNOPSIS)

BeginSection(IDENTIFIERS)
The first non-whitespace character on a line starts a definition:

BeginVerbatim
Line Identifiers
====================================================
Entry                   Character
====================================================
Comment                 'C'
Type                    'T'
Edge                    'E'
Literal Edge            'L'
Graph                   'G'
External Graph          'X'
Imported Graph          'I'
Node                    'N'
Begin Compound Node     '{'
End Compound Node       '}'
====================================================
EndVerbatim
EndSection(IDENTIFIERS)

BeginSection(COMMENTS)
Comments extend to the end of line.  Several predefined comments
(stamps) are used by the SISAL OSC compiler:

BeginVerbatim
Stamps
=====================================================================
Stamp
=====================================================================
C$  B CSU -> BUILD-IN-PLACE:  invar cse gcse fold sgnok
C$  C Faked IF1CHECK
C$  D Nodes are DFOrdered
C$  F Livermore Frontend   Version1.8
C$  I CSU -> IF1 OPTS: inline invar fiss cse fuse gcse asetl fold sgnok sfiss 
C$  M CSU -> MONOLITHIC
C$  N CSU -> NORMALIZED: native, dead
C$  P CSU -> PARTITIONED:  sgnok
C$  Q UR
C$  S CSU -> UNIVERSAL STREAM OWNERSHIP
C$  T Fri Dec 17 14:14:11 1993
C$  U CSU -> UPDATE-IN-PLACE: cagg ststr sgnok
C$  X CANN MODULES: ProgramNoDataBase
=====================================================================
EndVerbatim

Additional comments to direct a compiler or interpreter of the language
begin with a '%' and are followed by the two character pragma name.  
Arguments may be given to the pragma with an '=' after the name.
Since pragmas are terminated by whitespace, an argument may be
enclosed in '"' double quotes.  The following pragmas are used by
the SISAL OSC compiler:

BeginVerbatim
Pragmas
=====================================================================
Pragma   Description                     Argument/Set    Phase
=====================================================================

%cc      estimated cost                  <int>           U,P,G

%cm      consumer modify                 <int>           U,P,G
         (reference count decrement)

%fn      function name                   <str>           O,M,U,P,G  

%mk ENG  miscellaneous mark              <char>          O,M,U,P,G
    G    C language external             'c'    mark
                                         'd'    mark
    G    entry point                     'e'    mark
    G    Fortran language external       'f'    mark
                                         'i'    mark
                                         'p'    Pmark
         conditional exclusive right to  'r'    rmark1   U,P,G,L
         dope-vector
    G    secondary entry point           's'
                                         '@'    umark    O,M,U,P,G
         recursive function identifier;  'B'    bmark    U,P,G,L
         a backedge exists in the
         call graph from If2up
                                         'C'    cmark    U,P,G
                                         'D'    dmark    U,P,G
                                         'E'    emark    U,P,G
                                         'F'    fmark    U,P,G
                                         'I'    imark    U,P
                                         'L'    lmark    U,P,G
                                         'N'    nmark    U,P,G
         exclusive right to physical     'O'    omark1   U,P,G
         space
    E    data on edge has been built     'P'    pmark    M,U,P,G,L
         in place, task
         exclusive right to dope-vector  'R'    rmark1   U,L
         concurrent (parallel loops)     'S'    smark    U,P,G
    E    pass by value, vector           'V'    vmark    P,G
         internal to update-in-place     'W'             U,P,G

%na E    name                            <str>           O,M,U,P,G,L

%pl N    PL reference count              <int>           U,P,G
         node depth node in 
         dereference chain

%pm E    producer modify                 <int>           U,P,G
         (reference count increment)

%sf      source file                     <str>           O,M,U,P,G,L

%sl      source line                     <int> line      O,M,U,P,G,L

%sr  E   set reference count             <int>           U,P,G

%ID  C   compound unique identifier      <int>           M,U,P,G

%LS      loop slice formula              <str> LoopSlice G
         number of processors            "$P"
         low of range                    "$L"
         hight of range                  "$H"

%MS      minimum slide width             <str> MinSlice  P,G
         number of processors            "$P"
         low of range                    "$L"
         hight of range                  "$H"

%ST      style for loop paralelism       <char> Style    G
         GSS (guided self sched.)        'G'
         block                           'B'
         strided (stepped)               'S'
         runtime decision (stepped)      'R'

%TC      thin copy mark for loops        <none> ThinCopy M,U,P,G   
=====================================================================
Association:    E=Edge, N=Node, G=Graph, C=Compound
Argument:       range or value of defined pragma token
                <char>=single character, <int>=integer, <none>=none,
                <str>=string of characters
Set:            corresponding variable set when pragma is specified
Phase:          phase of OSC that instantiates the pragma
                O=if1opt, M=if2mem, U=if2up, P=if2part, G=if2gen, 
                L if the pragma is used in later phases of OSC
=====================================================================
EndVerbatim
EndSection(COMMENTS)

BeginSection(TYPES)
BeginVerbatim
Type Codes
===========================================================
Entry         TypeCode       Parameter1      Parameter2
===========================================================
Array                0       element label
Basic                1       base code
Field                2       field label     next field
Function             3       argument label  result label
Multiple             4       element label
Record               5       first field
(Record              5       element label   next field)
Stream               6       element label
Tag                  7       tag label       next tag
Tuple                8       element label   next tuple
Union                9       first tag
(Union               9       element label   next tag)
Unknown             10
Buffer              11
Set                 12       element label   next type
Reduction           13       init. tuple     function label
===========================================================

Base Codes
=======================
Entry         BaseCode
=======================
boolean              0
character            1
double               2
integer              3
null                 4
real                 5
=======================

Basic Types (example)
====================================================================
LineID  TypeLabel  TypeCode      BaseCode
====================================================================
T               1         1             0    %na=boolean
T               2         1             1    %na=character
T               3         1             2    %na=double
T               4         1             3    %na=integer
T               5         1             4    %na=null
T               6         1             5    %na=real
====================================================================

Array and Stream Types (example)
====================================================================
LineID  TypeLabel  TypeCode  ElementLabel
====================================================================
T              20         6             1    %na=stream[booleans]
T              76         0             6    %na=array[reals]
T             200         0            76    %na=array[array[reals]]
====================================================================

Record and Union Types (example)
====================================================================
LineID  TypeLabel  TypeCode  ElementLabel   NextLabel
====================================================================
C type cartesian = record[x, y: real]
T              20         5                        21  %na=cartesian
T              21         2             6          22  %na=x
T              22         2             6           0  %na=y
C type int_list = union[empty:null; 
C                       full:record[note:integer; next:int_list]]
C
T              30         8                        31  %na=int_list
T              31         7             5          32  %na=empty
T              32         7            33          0   %na=full
T              33         5                        34
T              34         2             2          35  %na=note
T              35         2            30           0  %na=next
====================================================================

Function Types (example)
====================================================================
LineID  TypeLabel  TypeCode ArgumentLabel ResultLabel
====================================================================
C function Filter(s:si; m:integer returns si)
T             100         3           101         103
====================================================================
LineID  TypeLabel  TypeCode  ElementLabel    NextType
====================================================================
T             101         8            50         102
T             102         8             4           0
T             103         8            50           0
====================================================================
EndVerbatim
EndSection(TYPES)

BeginSection(EDGES)
BeginVerbatim
====================================================================
LineID  Node    Port    Node         Port    Label  Literal
====================================================================
E       source  export  destination  import  type
L                       destintation import  type   "value"
====================================================================
EndVerbatim
EndSection(EDGES)


BeginSection(NODES)
BeginVerbatim
Nodes
==========================================
Name                   Number   Category
==========================================
IFForall                    0	Compound
IFSelect                    1
IFTagCase                   2
IFLoopA                     3
IFLoopB                     4
IFIfThenElse                5
IFIterate                   6
IFWhileLoop                 7
IFRepeatLoop                8
IFSeqForall                 9
IFUReduce                  10

IFAAddH                   100   Simple IF1
IFAAddL                   101
IFAAdjust                 102
IFABuild                  103
IFACatenate               104
IFAElement                105
IFAFill                   106
IFAGather                 107
IFAIsEmpty                108
IFALimH                   109
IFALimL                   110
IFARemH                   111
IFARemL                   112
IFAReplace                113
IFAScatter                114
IFASetL                   115
IFASize                   116
IFAbs                     117
IFBindArguments           118
IFBool                    119
IFCall                    120
IFChar                    121
IFDiv                     122
IFDouble                  123
IFEqual                   124
IFExp                     125
IFFirstValue              126
IFFinalValue              127
IFFloor                   128
IFInt                     129
IFIsError                 130
IFLess                    131
IFLessEqual               132
IFMax                     133
IFMin                     134
IFMinus                   135
IFMod                     136
IFNeg                     137
IFNoOp                    138
IFNot                     139
IFNotEqual                140
IFPlus                    141
IFRangeGenerate           142
IFRBuild                  143
IFRElements               144
IFRReplace                145
IFRedLeft                 146
IFRedRight                147
IFRedTree                 148
IFReduce                  149
IFRestValues              150
IFSingle                  151
IFTimes                   152
IFTrunc                   153
IFPrefixSize              154
IFError                   155
IFReplaceMulti            156

IFAAddLAT                 170   Simple IF2
IFAAddHAT                 171
IFABufPartition           172
IFABuildAT                173
IFABufScatter             174
IFACatenateAT             175
IFAElementAT              176
IFAExtractAT              177
IFAFillAT                 178
IFAGatherAT               179
IFARemHAT                 180
IFARemLAT                 181
IFAReplaceAT              182
IFArrayToBuf              183
IFASetLAT                 184
IFDefArrayBuf             185
IFDefRecordBuf            186
IFFinalValueAT            187
IFMemAlloc                188
IFBufElements             189
IFRBuildAT                190
IFRecordToBuf             191
IFRElementsAT             192
IFReduceAT                193
IFShiftBuffer             194
IFScatterBufPartitions    195
IFRedLeftAT               196
IFRedRightAT              197
IFRedTreeAT               198
IFAElementN               200
IFAElementP               201
IFAElementM               202

IFLoopPoolEnq             200
IFReadyListEnq            201
IFAssign                  202
IFGetArrayBase            203
IFOptAElement             204
IFDiv2                    205
IFUTagTest                206
IFUBuild                  207
IFUGetTag                 208
IFUElement                209
IFOptLoopPoolEnq          210
IFBuildSlices             211
IFAIndexMinus             220
IFAIndexPlus              221
IFFirstSum                222
IFFirstMin                223
IFFirstMax                224
IFTri                     225
IFFirstAbsMin             226
IFFirstAbsMax             227
IFAStore                  250
IFLeast                   251
IFGreatest                252
IFProduct                 253
IFSum                     254
IFGreat                   260
IFGreatEqual              261
IFBRBuild                 262
IFBRElements              263
IFBRReplace               264
IFSaveCallParam           266
IFSaveSliceParam          267
IFBuildLoopSlices         268
IFOptAReplace             269
IFMemAllocDVI             299
IFMemAllocDV              300
IFAAddHATDVI              301
IFAAddHATDV               302
IFAAddLATDVI              303
IFAAddLATDV               304
IFACatenateATDVI          305
IFACatenateATDV           306
IFABuildATDVI             307
IFABuildATDV              308
IFReduceATDVI             309
IFReduceATDV              310
IFAGatherATDVI            311
IFAGatherATDV             312
IFOptNoOp                 313
IFPeek                    314
IFRagged                  315
IFPSAllocCond             316
IFPSAllocOne              317
IFPSAllocTwo              318
IFPSAllocSpare1           319
IFPSAllocSpare2           320
IFPSFreeOne               321
IFPSFreeTwo               322
IFPSFreeSpare1            323
IFPSFreeSpare2            324
IFPSManager               325
IFPSManagerSwap           326
IFPSScatter               327
IFPSMemAllocDVI           328
IFSpawn                   330
IFRat                     331
IFWat                     332
IFSStep                   333
IFSAddH                   334
IFSBuild                  335
IFSCatenate               336
IFSGather                 337
IFSIsEmpty                338
IFSScatter                339
IFSSize                   340
IFSPrefixSize             341
IFAReplaceRange           400
IFAReplaceMulti           401
IFReduction               402

IFSGraph                 1000   Graph
IFLGraph                 1001
IFIGraph                 1002
IFXGraph                 1003
IFLPGraph                1004
IFRLGraph                1005

IFCBegin                 2000   Other
IFCEnd                   2001
IFEdge                   2002
IFLiteral                2003

IFUndefined              9999
==========================================
EndVerbatim
EndSection(NODES)
EndDocument
